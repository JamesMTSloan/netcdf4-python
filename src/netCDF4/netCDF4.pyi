from typing import Any, Optional, Union, Literal, Sequence
from types import TracebackType
from collections.abc import KeysView
from pathlib import Path

import numpy as np
from numpy.typing import DTypeLike, NDArray

__version__: str

def _gethdf5libversion() -> str: ...
def getlibversion() -> str: ...
def get_chunk_cache() -> tuple[int, int, float]: ...
def set_chunk_cache(
    size: Optional[int] = None,
    nelems: Optional[int] = None,
    preemption: Optional[float] = None,
) -> None: ...
def get_alignment() -> tuple[int, int]: ...
def set_alignment(threshold: int, alignment: int) -> None: ...

__netcdf4libversion__: str
__hdf5libversion__: str
__has_rename_grp__: int
__has_nc_inq_path__: int
__has_nc_inq_format_extended__: int
__has_cdf5_format__: int
__has_nc_open_mem__: int
__has_nc_create_mem__: int
__has_parallel4_support__: int
__has_pnetcdf_support__: int
__has_quantization_support__: int
__has_zstandard_support__: int
__has_bzip2_support__: int
__has_blosc_support__: int
__has_szip_support__: int
__has_set_alignment__: int

default_fillvals: dict[str, Union[int, float, str]]

is_native_little: bool
is_native_big: bool

_DataModelT = Literal[
    "NETCDF4",
    "NETCDF4_CLASSIC",
    "NETCDF3_CLASSIC",
    "NETCDF3_64BIT_OFFSET",
    "NETCDF3_64BIT_DATA",
]
_NetCDF4DTLike = Union[DTypeLike, "CompoundType", "VLType", "EnumType"]
_NetCDF4DT = Union[np.dtype, "CompoundType", "VLType", "EnumType"]

class Dataset:
    _grpid: int
    _isopen: int
    groups: dict[str, "Group"]
    dimensions: dict[str, "Dimension"]
    variables: dict[str, "Variable"]
    disk_format: Literal[
        "NETCDF3", "HDF5", "HDF4", "PNETCDF", "DAP2", "DAP4", "UNDEFINED"
    ]
    path: str
    parent: Optional["Dataset"]
    file_format: _DataModelT
    data_model: _DataModelT
    cmptypes: dict[str, "CompoundType"]
    vltypes: dict[str, "VLType"]
    enumtypes: dict[str, "EnumType"]
    __orthogonal_indexing__: bool
    keepweakref: bool
    _ncstring_attrs__: bool

    def __init__(
        self,
        filename: Union[str, Path],
        mode: str = "r",
        clobber: bool = True,
        format: _DataModelT = "NETCDF4",
        diskless: bool = False,
        persist: bool = False,
        keepweakref: bool = False,
        memory: Optional[Any] = None,
        encoding: Optional[str] = None,
        parallel: bool = False,
        comm: Optional[Any] = None,
        info: Optional[Any] = None,
        **kwargs: Any
    ): ...
    def __enter__(self) -> "Dataset": ...
    def __exit__(
        self,
        atype: Optional[type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[TracebackType],
    ) -> None: ...
    def __getitem__(self, elem: str) -> Union["Group", "Variable"]: ...
    def filepath(self, encoding: Optional[str] = None) -> str: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def _close(self, check_err: bool) -> None: ...
    def close(self) -> Optional[memoryview]: ...
    def isopen(self) -> bool: ...
    def __dealloc__(self) -> None: ...
    def __reduce__(self) -> Union[str, tuple[Any, ...]]: ...
    def sync(self) -> None: ...
    def _redef(self) -> None: ...
    def _enddef(self) -> None: ...
    def set_fill_on(self) -> None: ...
    def set_fill_off(self) -> None: ...
    def createDimension(
        self, dimname: str, size: Optional[int] = None
    ) -> "Dimension": ...
    def renameDimension(self, oldname: str, newname: str) -> None: ...
    def createCompoundType(
        self, datatype: DTypeLike, datatype_name: str
    ) -> "CompoundType": ...
    def createVLType(self, datatype: DTypeLike, datatype_name: str) -> "VLType": ...
    def createEnumType(
        self, datatype: DTypeLike, datatype_name: str, enum_dict: dict[str, int]
    ) -> "EnumType": ...
    def createVariable(
        self,
        varname: str,
        datatype: _NetCDF4DTLike,
        dimensions: Union[Sequence[Union[str, "Dimension"]], str, "Dimension"] = (),
        compression: Optional[str] = None,
        zlib: bool = False,
        complevel: Optional[int] = 4,
        shuffle: bool = True,
        szip_coding: Literal["nn", "ec"] = "nn",
        szip_pixels_per_block: Literal[4, 8, 16, 32] = 8,
        blosc_shuffle: Literal[0, 1, 2] = 1,
        fletcher32: bool = False,
        contiguous: bool = False,
        chunksizes: Optional[int] = None,
        endian: Literal["native", "little", "big"] = "native",
        least_significant_digit: Optional[int] = None,
        significant_digits: Optional[int] = None,
        quantize_mode: Literal["BitGroom", "BitRound", "GranularBitRound"] = "BitGroom",
        fill_value: Optional[Any] = None,
        chunk_cache: Optional[int] = None,
    ) -> "Variable": ...
    def renameVariable(self, oldname: str, newname: str) -> None: ...
    def createGroup(self, groupname: str) -> "Group": ...
    def ncattrs(self) -> Union[list[str], KeysView]: ...
    def setncattr(self, name: str, value: Any) -> None: ...
    def setncattr_string(self, name: str, value: Union[str, Sequence[str]]) -> None: ...
    def setncatts(self, attdict: dict[str, Any]) -> None: ...
    def getncattr(self, name: str, encoding: str = "utf-8") -> Any: ...
    def __delattr__(self, name: str) -> None: ...
    def delncattr(self, name: str) -> None: ...
    def __setattr__(self, name: str, value: Any) -> None: ...
    def __getattr__(self, name: str) -> Any: ...
    def renameAttribute(self, oldname: str, newname: str) -> None: ...
    def renameGroup(self, oldname: str, newname: str) -> None: ...
    def set_auto_chartostring(self, value: bool) -> None: ...
    def set_auto_maskandscale(self, value: bool) -> None: ...
    def set_auto_mask(self, value: bool) -> None: ...
    def set_auto_scale(self, value: bool) -> None: ...
    def set_always_mask(self, value: bool) -> None: ...
    def set_ncstring_attrs(self, value: bool) -> None: ...
    def get_variables_by_attributes(self, **kwargs: Any) -> list["Variable"]: ...
    def _getname(self) -> str: ...
    @property
    def name(self) -> str: ...
    @staticmethod
    def fromcdl(
        cdlfilename: Union[str, Path],
        ncfilename: Optional[Union[str, Path]] = None,
        mode: str = "a",
        format: _DataModelT = "NETCDF4",
    ) -> "Dataset": ...
    def tocdl(
        self,
        coordvars: bool = False,
        data: bool = False,
        outfile: Optional[Union[str, Path]] = None,
    ) -> Optional[Union[str, bytes]]: ...
    def has_blosc_filter(self) -> bool: ...
    def has_zstd_filter(self) -> bool: ...
    def has_bzip2_filter(self) -> bool: ...
    def has_szip_filter(self) -> bool: ...

class Group(Dataset):
    def __init__(self, parent: Union[Dataset, "Group"], name: str, **kwargs: Any): ...
    def close(self) -> None: ...

class Dimension:
    _dimid: int
    _grpid: int
    _data_model: _DataModelT
    _name: str
    _grp: Union[Dataset, Group]

    def __init__(
        self,
        grp: Union[Dataset, Group],
        name: str,
        size: Optional[int] = None,
        **kwargs: Any
    ): ...
    def _getname(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def size(self) -> int: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __len__(self) -> int: ...
    def group(self) -> Union[Dataset, Group]: ...
    def isunlimited(self) -> bool: ...

class Variable:
    _varid: int
    _grpid: int
    _nunlimdim: int
    _name: str
    ndim: int
    dtype: _NetCDF4DT
    mask: bool
    scale: bool
    always_mask: bool
    chartostring: bool
    _isprimitive: bool
    _iscompound: bool
    _isvlen: bool
    _isenum: bool
    _grp: Union[Dataset, Group]
    _cmptype: Optional["CompoundType"]
    _vltype: Optional["VLType"]
    _enumtype: Optional["EnumType"]
    __orthogonal_indexing__: bool
    _has_lsd: Optional[bool]
    _use_get_vars: bool
    _ncstring_attrs__: bool

    def __init__(
        self,
        grp: Union[Dataset, Group],
        name: str,
        datatype: _NetCDF4DTLike,
        dimensions: tuple[Union[str, "Dimension"], ...] = (),
        compression: Optional[str] = None,
        zlib: bool = False,
        complevel: Optional[int] = 4,
        shuffle: bool = True,
        szip_coding: Literal["nn", "ec"] = "nn",
        szip_pixels_per_block: Literal[4, 8, 16, 32] = 8,
        blosc_shuffle: Literal[0, 1, 2] = 1,
        fletcher32: bool = False,
        contiguous: bool = False,
        chunksizes: Optional[int] = None,
        endian: Literal["native", "little", "big"] = "native",
        least_significant_digit: Optional[int] = None,
        significant_digits: Optional[int] = None,
        quantize_mode: Literal["BitGroom", "BitRound", "GranularBitRound"] = "BitGroom",
        fill_value: Optional[Any] = None,
        chunk_cache: Optional[int] = None,
        **kwargs: Any
    ): ...
    def __array__(self) -> NDArray: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def _getdims(self) -> tuple[str, ...]: ...
    def _getname(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def datatype(self) -> np.dtype: ...
    @property
    def shape(self) -> tuple[int, ...]: ...
    @property
    def size(self) -> int: ...
    @property
    def dimensions(self) -> tuple[str, ...]: ...
    def group(self) -> Union[Dataset, Group]: ...
    def ncattrs(self) -> list[str]: ...
    def setncattr(self, name: str, value: Any) -> None: ...
    def setncattr_string(self, name: str, value: Union[str, Sequence[str]]) -> None: ...
    def setncatts(self, attdict: dict[str, Any]) -> None: ...
    def getncattr(self, name: str, encoding: str = "utf-8") -> Any: ...
    def delncattr(self, name: str) -> None: ...
    def filters(self) -> dict[str, Any]: ...
    def quantization(self) -> Optional[tuple[int, str]]: ...
    def endian(self) -> Literal["native", "little", "big"]: ...
    def chunking(self) -> Union[Literal["contiguous"], list[int]]: ...
    def get_var_chunk_cache(self) -> tuple[int, int, float]: ...
    def set_var_chunk_cache(
        self,
        size: Optional[int] = None,
        nelems: Optional[int] = None,
        preemption: Optional[float] = None,
    ) -> None: ...
    def __delattr__(self, name: str) -> None: ...
    def __setattr__(self, name: str, value: Any) -> None: ...
    def __getattr__(self, name: str) -> Any: ...
    def renameAttribute(self, oldname: str, newname: str) -> None: ...
    def __getitem__(self, elem: Any) -> Any: ...
    def _toma(self, data: NDArray) -> np.ma.MaskedArray: ...
    def _pack(self, data: NDArray) -> NDArray: ...
    def _assign_vlen(self, elem: Any, data: NDArray) -> None: ...
    def _check_safecast(self, attname: str) -> bool: ...
    def __setitem__(self, elem: Any, data: Any) -> None: ...
    def __len__(self) -> int: ...
    def assignValue(self, val: Any) -> None: ...
    def getValue(self) -> Any: ...
    def set_auto_chartostring(self, chartostring: bool) -> None: ...
    def use_nc_get_vars(self, use_nc_get_vars: bool) -> None: ...
    def set_auto_maskandscale(self, maskandscale: bool) -> None: ...
    def set_auto_scale(self, scale: bool) -> None: ...
    def set_auto_mask(self, mask: bool) -> None: ...
    def set_always_mask(self, always_mask: bool) -> None: ...
    def set_ncstring_attrs(self, ncstring_attrs: bool) -> None: ...
    def _put(self, data: NDArray, start: int, count: int, stride: int) -> None: ...
    def _get(self, start: int, count: int, stride: int) -> NDArray: ...
    def set_collective(self, value: bool) -> None: ...
    def get_dims(self) -> tuple[Dimension, ...]: ...
    def __reduce__(self) -> Union[str, tuple[Any, ...]]: ...

class CompoundType:
    _nc_type: np.dtype
    dtype: np.dtype
    dtype_view: np.dtype

    def __init__(
        self, grp: Union[Dataset, Group], dt: DTypeLike, dtype_name: str, **kwargs: Any
    ): ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __reduce__(self) -> Union[str, tuple[Any, ...]]: ...

class VLType:
    _nc_type: np.dtype
    dtype: np.dtype
    name: np.dtype
    def __init__(
        self, grp: Union[Dataset, Group], dt: DTypeLike, dtype_name: str, **kwargs: Any
    ): ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __reduce__(self) -> Union[str, tuple[Any, ...]]: ...

class EnumType:
    _nc_type: np.dtype
    dtype: np.dtype
    name: str
    enum_dict: dict[str, int]
    def __init__(
        self,
        grp: Union[Dataset, Group],
        dt: DTypeLike,
        dtype_name: str,
        enum_dict: dict[str, int],
        **kwargs: Any
    ): ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __reduce__(self) -> Union[str, tuple[Any, ...]]: ...

def stringtoarr(
    string: str, NUMCHARS: int, dtype: Literal["S", "U"] = "S"
) -> NDArray: ...
def stringtochar(a: NDArray, encoding: str = "utf-8") -> NDArray: ...
def chartostring(b: NDArray, encoding: str = "utf-8") -> NDArray: ...

class MFDataset(Dataset):
    def __init__(
        self,
        files: Union[Sequence[str], str],
        check: bool = False,
        aggdim: Optional[str] = None,
        exclude: list[str] = [],
        master_file: Optional[str] = None,
    ): ...
    def __setattr__(self, name: str, value: Any) -> None: ...
    def __getattribute__(self, name: str) -> Any: ...
    def ncattrs(self) -> Union[list[str], KeysView]: ...
    def close(self) -> None: ...
    def __repr__(self) -> str: ...
    def __reduce__(self) -> Union[str, tuple[Any, ...]]: ...

class _Dimension:
    def __init__(self, dimname: str, dim: Any, dimlens: Any, dimtotlen: int): ...
    def __len__(self) -> int: ...
    def isunlimited(self) -> bool: ...
    def __repr__(self) -> str: ...

class _Variable:
    def __init__(
        self, dset: Union[Dataset, Group], varname: str, var: Variable, recdimname: str
    ): ...
    def typecode(self) -> DTypeLike: ...
    def ncattrs(self) -> KeysView: ...
    def __getattr__(self, name: str) -> Any: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def _shape(self) -> tuple[int, ...]: ...
    def set_auto_chartostring(self, val: bool) -> None: ...
    def set_auto_maskandscale(self, val: bool) -> None: ...
    def set_auto_mask(self, val: bool) -> None: ...
    def set_auto_scale(self, val: bool) -> None: ...
    def set_always_mask(self, val: bool) -> None: ...
    def __getitem__(self, elem: Any) -> NDArray: ...

class MFTime(_Variable):
    def __init__(
        self,
        time: Variable,
        units: Optional[str] = None,
        calendar: Optional[str] = None,
    ): ...
    def __getitem__(self, elem: Any) -> NDArray: ...
